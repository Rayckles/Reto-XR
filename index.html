<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>AR WebXR — Starter</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0e13; color:#e7ecef; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    #ui { position: fixed; inset: 0 0 auto 0; display:flex; gap:.5rem; align-items:center; padding:.6rem .8rem; background: linear-gradient(180deg, rgba(11,14,19,.85), rgba(11,14,19,.2) 70%, transparent); z-index: 10; }
    #ui input[type="text"]{ flex:1; min-width:0; background:#151a22; border:1px solid #2a3441; color:#e7ecef; padding:.55rem .7rem; border-radius:.8rem; outline:none; }
    #ui button, .fab { background:#1d2430; color:#e7ecef; border:1px solid #2a3441; padding:.55rem .8rem; border-radius:.9rem; cursor:pointer; font-weight:600; letter-spacing:.2px; }
    #ui button:hover, .fab:hover { filter:brightness(1.1); }
    .fab { position: fixed; right:.8rem; bottom:.8rem; z-index: 11; padding:.7rem 1rem; }
    .hint { position: fixed; left:50%; transform: translateX(-50%); bottom:5.8rem; background: rgba(0,0,0,.45); padding:.5rem .7rem; border-radius:.6rem; font-size:.9rem; backdrop-filter: blur(4px); border:1px solid rgba(255,255,255,.1); display:none; }
    .reticle { position:fixed; left:50%; top:50%; transform: translate(-50%, -50%); width:56px; height:56px; border-radius:50%; pointer-events:none; display:none; }
    .reticle::before, .reticle::after { content:""; position:absolute; inset:0; border-radius:50%; }
    .reticle::before { border:2px dashed #89f7fe; opacity:.8; }
    .reticle::after { border:2px solid #89f7fe33; transform: scale(.6); }
    .toast { position: fixed; left:50%; transform: translateX(-50%); top:.8rem; background:#111722; color:#e7ecef; padding:.55rem .8rem; border-radius:.7rem; border:1px solid #2a3441; display:none; z-index: 50; }
    #credits{ position:fixed; bottom:.8rem; left:.8rem; font-size:.8rem; opacity:.8; }
    #canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
  <!-- Top UI -->
    <div id="ui">
    <span style="opacity:.8">Modelo bloqueado por el autor</span>
    <button id="btnReset">Reiniciar</button>
    <button id="btnHelp">Ayuda</button>
  </div>

  <!-- Enter AR button injected by ARButton (also provide fallback FAB) -->
  <button class="fab" id="enterAR">Entrar en AR</button>

  <div class="hint" id="hint">Mueve el móvil para encontrar una superficie… toca para colocar · pinza = escala · giro con dos dedos = rotar</div>
  <div class="reticle" id="reticle"></div>
  <div class="toast" id="toast"></div>
  <div id="credits">WebXR • three.js</div>
  <canvas id="canvas"></canvas>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.1/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.1/examples/jsm/controls/OrbitControls.js';
    import { ARButton } from 'https://unpkg.com/three@0.160.1/examples/jsm/webxr/ARButton.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.1/examples/jsm/loaders/GLTFLoader.js';

    // DOM
    const canvas = document.getElementById('canvas');
const fabEnter = document.getElementById('enterAR');
const hint = document.getElementById('hint');
const reticleEl = document.getElementById('reticle');
const toastEl = document.getElementById('toast');
const btnReset = document.getElementById('btnReset');
const btnHelp = document.getElementById('btnHelp');

// 🔒 URL fija del modelo (pon aquí el enlace RAW de GitHub)
const MODEL_URL = 'https://github.com/Rayckles/Reto-XR/raw/refs/heads/main/rumi__fortnite_skin__fortnite_x_kpdh.glb'; // <-- reemplaza USUARIO/REPO/rama

    // Three basics
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, canvas });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.xr.enabled = true;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 50);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x334155, 1.0); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(0.5, 1, 0.3); scene.add(dir);

    // Non‑AR orbit mode (desktop preview)
    const controls = new OrbitControls(camera, renderer.domElement);
    camera.position.set(0, 1.2, 2.4);
    controls.target.set(0, 1, 0);
    controls.update();

    // Reticle (for placement feedback)
    const reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.08, 0.1, 48).rotateX(-Math.PI/2),
      new THREE.MeshBasicMaterial({ color: 0x89f7fe })
    );
    reticle.matrixAutoUpdate = false;

    // Content root for placed objects
    const content = new THREE.Group(); scene.add(content);

    // Ground for desktop preview
    const previewGround = new THREE.Mesh(
      new THREE.PlaneGeometry(10, 10),
      new THREE.MeshStandardMaterial({ color: 0x202833, metalness:0, roughness:1 })
    );
    previewGround.rotation.x = -Math.PI/2;
    previewGround.position.y = 0;
    scene.add(previewGround);

    // Current placed object reference
    let placed = null;

// Prevenir interacción si el modelo no está listo
let modelReady = false;

    function makeFallbackCube() {
      const g = new THREE.BoxGeometry(.3, .3, .3);
      const m = new THREE.MeshStandardMaterial({ color: 0x6ee7ff, metalness:.1, roughness:.35 });
      const cube = new THREE.Mesh(g, m);
      cube.castShadow = true; cube.receiveShadow = true;
      return cube;
    }

    async function loadModel(url) {
      return new Promise((resolve, reject) => {
        const loader = new GLTFLoader();
        loader.load(url, (gltf)=>{
          const root = gltf.scene || gltf.scenes[0];
          resolve(root);
        }, undefined, (e)=> reject(e));
      });
    }

    function toast(msg, ms=1800){
      toastEl.textContent = msg;
      toastEl.style.display = 'block';
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=> toastEl.style.display = 'none', ms);
    }

    // Gesture handling (scale/rotate)
    let pointers = new Map();
    let baseDistance = 0, baseAngle = 0, startScale = 1, startRotationY = 0;

    function onPointerDown(e){ pointers.set(e.pointerId, e); }
    function onPointerMove(e){
      if(!placed) return; 
      if(!pointers.has(e.pointerId)) return; 
      pointers.set(e.pointerId, e);
      if(pointers.size === 2){
        const [p1, p2] = [...pointers.values()];
        const dx = p2.clientX - p1.clientX; const dy = p2.clientY - p1.clientY;
        const dist = Math.hypot(dx, dy);
        const angle = Math.atan2(dy, dx);
        if(!baseDistance){ baseDistance = dist; baseAngle = angle; startScale = placed.scale.x; startRotationY = placed.rotation.y; }
        const scale = THREE.MathUtils.clamp(startScale * (dist/baseDistance), 0.1, 8);
        placed.scale.setScalar(scale);
        placed.rotation.y = startRotationY + (angle - baseAngle);
      }
    }
    function onPointerUp(e){ pointers.delete(e.pointerId); if(pointers.size<2){ baseDistance=0; baseAngle=0; } }

    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
    renderer.domElement.addEventListener('pointercancel', onPointerUp);

    // AR session & hit‑test
    let xrRefSpace = null;
    let hitTestSource = null;
    let isAR = false;

    async function startAR(){
      if(!navigator.xr){ toast('Este navegador no soporta WebXR'); return; }
      const supported = await navigator.xr.isSessionSupported('immersive-ar');
      if(!supported){ toast('Tu dispositivo no soporta "immersive-ar"'); return; }

      const sessionInit = { requiredFeatures: ['hit-test', 'dom-overlay'], domOverlay: { root: document.body } };
      const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
      renderer.xr.setReferenceSpaceType('local');
      await renderer.xr.setSession(session);
      isAR = true; hint.style.display = 'block'; reticleEl.style.display = 'block';

      // Hit‑test source
      const xrViewerSpace = await session.requestReferenceSpace('viewer');
      hitTestSource = await session.requestHitTestSource({ space: xrViewerSpace });
      xrRefSpace = await session.requestReferenceSpace('local');

      session.addEventListener('end', ()=>{
        isAR = false; hint.style.display='none'; reticleEl.style.display='none';
        scene.remove(reticle);
      });

      // Tap to place
      session.addEventListener('select', ()=>{
  if(!lastHit) return;
  if(!modelReady){ toast('Espera: cargando modelo…'); return; }
  if(!placed){ placed = currentModel; if(!content.children.includes(placed)) content.add(placed); }
  placed.position.setFromMatrixPosition(reticle.matrix);
  placed.quaternion.setFromRotationMatrix(reticle.matrix);
  toast('Objeto colocado. Pinza=escala • Dos dedos=girar');
}); content.add(placed); }
        placed.position.setFromMatrixPosition(reticle.matrix);
        placed.quaternion.setFromRotationMatrix(reticle.matrix);
        toast('Objeto colocado. Pinza=escala • Dos dedos=girar');
      });

      // Add reticle to scene for AR only
      scene.add(reticle);
    }

    // Model management
    let currentModel = null;

    async function setModelFromInput(){
  const url = MODEL_URL.trim();
  if(!url){ toast('Falta URL del modelo (configura MODEL_URL)'); return; }
  try{
    const root = await loadModel(url);
    root.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; } });
    if(currentModel) content.remove(currentModel);
    currentModel = root;
    modelReady = true;
    if(!isAR){
      currentModel.position.set(0, 0, 0);
      content.add(currentModel);
    }
    toast('Modelo cargado ✔️');
  }catch(err){ console.error(err); toast('Error cargando el modelo (revisa el enlace RAW)'); }
} });
          if(currentModel) content.remove(currentModel);
          currentModel = root;
          if(!isAR){
            // show on ground in preview mode
            currentModel.position.set(0, 0, 0);
            content.add(currentModel);
          }
          toast('Modelo cargado ✔️');
        } else {
          // fallback cube
          if(currentModel) content.remove(currentModel);
          currentModel = makeFallbackCube();
          if(!isAR){ currentModel.position.set(0, .15, 0); content.add(currentModel); }
          toast('Usando cubo por defecto');
        }
      }catch(err){ console.error(err); toast('Error cargando el modelo'); }
    }

    // (carga automática — sin botón) 
    btnReset.addEventListener('click', ()=>{ content.clear(); placed=null; currentModel=null; modelReady=false; setModelFromInput(); toast('Escena reiniciada'); }); placed=null; currentModel=null; toast('Escena reiniciada'); });
    btnHelp.addEventListener('click', ()=>{
      alert('Cómo usar:

1) Pulsa "Entrar en AR" (móvil Android/Chrome, HTTPS).
2) Mueve el dispositivo para escanear superficies (aparecerá una diana).
3) Toca la pantalla para colocar el objeto (modelo bloqueado por el autor).
4) Pinza para escalar, dos dedos para girar.');
    });

    // Enter AR via ARButton (inserts a native-styled button); also bind our FAB
    const arButton = ARButton.createButton(renderer, { requiredFeatures: ['hit-test', 'dom-overlay'], domOverlay: { root: document.body } });
    arButton.style.display = 'none'; // hide default, we use custom FAB
    document.body.appendChild(arButton);
    fabEnter.addEventListener('click', ()=> arButton.click());

    // Hit‑test loop
    let lastHit = null;
    renderer.setAnimationLoop((t, frame)=>{
      if(isAR && frame){
        const refSpace = xrRefSpace;
        const hitTestResults = hitTestSource ? frame.getHitTestResults(hitTestSource) : [];
        if(hitTestResults.length){
          const pose = hitTestResults[0].getPose(refSpace);
          if(pose){
            reticle.visible = true; reticleEl.style.display='block';
            reticle.matrix.fromArray(pose.transform.matrix);
            lastHit = pose;
          }
        } else {
          reticle.visible = false; reticleEl.style.display='none';
          lastHit = null;
        }
      }
      renderer.render(scene, camera);
    });

    // Resize
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initial
    setModelFromInput();

  </script>
</body>
</html>
